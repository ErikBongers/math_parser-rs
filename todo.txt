* implement strict
  > trig functions require unit and do not assume rad.

* number strings.
  > allow underscores? Currency signs? Minus? Exponential?
  > merge with the normal parse_decimal function?

* post-build
  > revisit this as it's dependent on this inc_version tool, but that's not in the tool_chain.
  > check out https://crates.io/crates/cargo-post
  > also check how to include dev dependencies in cargo.
  > perhaps create a github repo so version_inc can be downloaded?
     > now version_inc path is hard coded and is a separate project.
  > test a clean clone repo from github. ideally it should run.

* Dates:
  : lastDay=now().year, 12, 'last'; //31, 30 28 or 29?
    date(lastDay).day; --> returns 99 !

* NodeData: needed?

* copy tests from c++

* google login: failes more than not.
  > order of scripts?

* document all unwraps.
  > just a comment to explain why unwrap() is safe.

* invalidate reference in PeekingTokenizer?
  : let first = tok.peek();
    tok.next();
    first --> references the SECOND token!!

* Allow a block in the middle of an expression?
  > At least an assign expression?

* Don't report internal error message:
  : "30thou.mm; --> "Error: resolve_node blabla..."

* date and duration.
  > implement remaining operators.

* Months:
  > use #[repr(u8)]

* Scope borrows.
  > see if if Scope, which changes during resolving, can be moved into a ResolverState object,
  > See formatted_date_parser.

* exponents

* to examine TokenStream for macros:
  > https://github.com/dtolnay/proc-macro-workshop
  > https://dev.to/dandyvica/rust-procedural-macros-step-by-step-tutorial-36n8

* Range: replace { start, end } with &str? It's essentially the same and it's safer.
  > byte indexes can probably still be calculated -> see cursor?

* rethink echo comments
  > only allowed on a separate line and in between statements!
  > cursor needs to  mark when a newline has begun.
    > only SET this flag, to avoid constant clearing of it.
    > who clears the flag? The tokenizer, when a statement is completed.
  - allow for formatted text
  "the result of a+b = 123.4"
  : !// the result of !`a+b` = $
  > where $ is the last value.
  "the result of a+b = 123.4, and if you subtract .4, you get 123."
  : !// the result of !`a+b` = $, and if you subtract `.4`, you get `$0 - $1`.
  > `a+b` ==> executed and the result is output.
  > !`a+b` ==> executed and the code is output.

 source_index is a 'pointer': replace with a life-timed value?

* add tests to cursor.rs
  > move the tests from main.rs.

* AST
  - trait AstNode to cast: https://github.com/rust-lang/rust-analyzer/blob/337e2abb670d403ae05609c5f1aafcffbd3369a6/crates/syntax/src/ast.rs#L43
  - downcasting a trait object to a specific (exact and original) object : https://stackoverflow.com/questions/33687447/how-to-get-a-reference-to-a-concrete-type-from-a-trait-object?rq=3





* Span to LinePos:
  - https://doc.rust-lang.org/beta/nightly-rustc/src/rustc_span/source_map.rs.html#509
  - lookup_char_pos(BytePos0 -> Loc: https://doc.rust-lang.org/beta/nightly-rustc/src/rustc_span/source_map.rs.html#402
  - >>> lookup_file_pos() https://doc.rust-lang.org/beta/nightly-rustc/src/rustc_span/lib.rs.html#1804
  - count lines and multi byte chars: https://doc.rust-lang.org/beta/nightly-rustc/src/rustc_span/analyze_source_file.rs.html#195



* functions don't check param types: Exception thrown!

* Functions
  > round(), ... on lists?
    > eg make a list all integers.
