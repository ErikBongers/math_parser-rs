* ErrorId: implement with macro?
  > Can't split a string literal.
  > Macro should create an Error object containing
    - the formatted error message, given n arguments
    - error id
    - range
    ...
  > Perhaps a macro that takes the ID and generates a constant &str with the ID_STR name?
    > another macro that 'takes' the ID_STR based on the ID to format!() the message?

* number strings.
  > allow underscores? Currency signs? Minus? Exponential?
  > merge with the normal parse_decimal function?

* post-build
  > install inc_version:
    : cargo install --git https://github.com/ErikBongers/inc_version
    > this installs inc_version.exe in C:\Users\erikb\.cargo\bin
  > check out https://crates.io/crates/cargo-post

* Copy TODOs from C++ project.

* implement a ~= operator to approximately compare floats.
  > PI ~= 3.14
  > we don't have if statements, so...not usefull?

* implement delta symbol shortcut...ctrl D?

* google login: fails more than not.
  > order of scripts?

* document all unwraps.
  > just a comment to explain why unwrap() is safe.

* Allow a block in the middle of an expression?
  > At least an assign expression?

* Scope borrows.
  > see if Scope, which changes during resolving, can be moved into a ResolverState object,
  > See formatted_date_parser.

* to examine TokenStream for macros:
  > https://github.com/dtolnay/proc-macro-workshop
  > https://dev.to/dandyvica/rust-procedural-macros-step-by-step-tutorial-36n8

* Range: replace { start, end } with &str? It's essentially the same and it's safer.
  > byte indexes can probably still be calculated -> see cursor?
  > or implement the same way as SourceIndex?

* rethink echo comments
  > only allowed on a separate line and in between statements!
  > cursor needs to  mark when a newline has begun.
    > only SET this flag, to avoid constant clearing of it.
    > who clears the flag? The tokenizer, when a statement is completed.
  - allow for formatted text
  "the result of a+b = 123.4"
  : !// the result of !`a+b` = $
  > where $ is the last value.
  "the result of a+b = 123.4, and if you subtract .4, you get 123."
  : !// the result of !`a+b` = $, and if you subtract `.4`, you get `$0 - $1`.
  > `a+b` ==> executed and the result is output.
  > !`a+b` ==> executed and the code is output.

 source_index is a 'pointer': replace with a life-timed value?

* AST
  - trait AstNode to cast: https://github.com/rust-lang/rust-analyzer/blob/337e2abb670d403ae05609c5f1aafcffbd3369a6/crates/syntax/src/ast.rs#L43
  - downcasting a trait object to a specific (exact and original) object : https://stackoverflow.com/questions/33687447/how-to-get-a-reference-to-a-concrete-type-from-a-trait-object?rq=3





* Span to LinePos:
  - https://doc.rust-lang.org/beta/nightly-rustc/src/rustc_span/source_map.rs.html#509
  - lookup_char_pos(BytePos0 -> Loc: https://doc.rust-lang.org/beta/nightly-rustc/src/rustc_span/source_map.rs.html#402
  - >>> lookup_file_pos() https://doc.rust-lang.org/beta/nightly-rustc/src/rustc_span/lib.rs.html#1804
  - count lines and multi byte chars: https://doc.rust-lang.org/beta/nightly-rustc/src/rustc_span/analyze_source_file.rs.html#195



* functions don't check param types: Exception thrown!

* Functions
  > round(), ... on lists?
    > eg make a list all integers.
